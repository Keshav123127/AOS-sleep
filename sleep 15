Q.1) Display all the files from current directory whose size is greater that n Bytes Where n is accept
from user

#include <stdio.h>
#include <stdlib.h>
#include <dirent.h>
#include <sys/stat.h>

int main() {
    DIR *dir;
    struct dirent *entry;
    struct stat fileStat;
    long n;

    // Accept size limit from user
    printf("Enter the minimum file size in bytes: ");
    scanf("%ld", &n);

    // Open current directory
    dir = opendir(".");
    if (dir == NULL) {
        perror("opendir failed");
        exit(1);
    }

    printf("\nFiles greater than %ld bytes:\n", n);
    printf("------------------------------------\n");

    // Read directory entries one by one
    while ((entry = readdir(dir)) != NULL) {
        // Skip "." and ".."
        if (entry->d_name[0] == '.')
            continue;

        // Get file details
        if (stat(entry->d_name, &fileStat) == -1) {
            perror("stat failed");
            continue;
        }

        // Check if itâ€™s a regular file and larger than n bytes
        if (S_ISREG(fileStat.st_mode) && fileStat.st_size > n) {
            printf("%s\t(%ld bytes)\n", entry->d_name, fileStat.st_size);
        }
    }

    closedir(dir);
    return 0;
}

Q.2) Write a C program which creates a child process to run linux/ unix command or any user defined
program. The parent process set the signal handler for death of child signal and Alarm signal. If
a child process does not complete its execution in 5 second then parent process kills child process

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <sys/wait.h>

pid_t child_pid;

// Signal handler for SIGCHLD (child terminated)
void child_handler(int sig) {
    int status;
    wait(&status);
    printf("\n[Parent] Child process terminated.\n");
    if (WIFEXITED(status))
        printf("[Parent] Child exited with status: %d\n", WEXITSTATUS(status));
    else if (WIFSIGNALED(status))
        printf("[Parent] Child killed by signal: %d\n", WTERMSIG(status));
    exit(0);
}

// Signal handler for SIGALRM (timeout)
void alarm_handler(int sig) {
    printf("\n[Parent] Child did not finish within 5 seconds.\n");
    printf("[Parent] Killing child process (PID: %d)...\n", child_pid);
    kill(child_pid, SIGKILL);
}

int main() {
    // Register signal handlers
    signal(SIGCHLD, child_handler);
    signal(SIGALRM, alarm_handler);

    // Fork a child process
    child_pid = fork();

    if (child_pid < 0) {
        perror("fork failed");
        exit(1);
    }
    else if (child_pid == 0) {
        // Child process
        printf("[Child] Running 'sleep 10' command...\n");
        execlp("sleep", "sleep", "10", NULL); // Replace with any command or user program
        perror("execlp failed");
        exit(1);
    }
    else {
        // Parent process
        printf("[Parent] Started child with PID: %d\n", child_pid);
        alarm(5);  // Set 5-second timer

        // Wait indefinitely; signals handle what happens next
        while (1)
            pause();
    }

    return 0;
}
